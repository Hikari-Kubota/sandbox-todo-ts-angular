<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>TypeScript Notes</title>
    <style type="text/css">
        li {
            margin-top: 20px;
        }
        .code {
            padding-left: 10px;
            margin-top: 10px;
            border: solid 1px rgb(4, 112, 73);
            background-color: rgba(4, 112, 73, 0.1);
            white-space: pre;
        }

        .log {
            padding-left: 10px;
            margin-top: 10px;
            border: solid 1px rgb(223, 180, 126);
            background-color: rgba(223, 180, 126, 0.1);
            white-space: pre;
        }
    </style>
</head>

<body ng-app='app' style="margin: 50px;">
    <a href="../index.html">戻る</a>
    <h1>TypeScript Notes</h1>
    <p>
        <a href="https://www.typescriptlang.org/docs/tutorial.html" target="_blank">Quick start &middot; TypeScript</a> を読んだ上でのメモなど。
    </p>
    凡例
    <div class="code" style="width: 150px;">コード or コマンド</div>
    <div class="log" style="width: 50px;">出力</div>
    <ul>
        参考
        <li>
            <a href="http://www.slideshare.net/jsakamoto/type-script-49408371">TypeScript入門 ―素のJavaScriptとはさようなら！―</a>
        </li>
        <li>
            <a href="http://www.buildinsider.net/language/quicktypescript/01">TypeScript早わかりチートシート【1.5.3対応】</a>
        </li>
    </ul>

    <!-- 4/19 -->
    <h2>Basic Types</h2>
    <h3>静的型付け</h3>
    <div class="code">
        let isDone: number = 'Hello!';
    </div>
    <div class="log">
        sample.ts(1,5): error TS2322: Type 'string' is not assignable to type 'number'.
    </div>

    <h3>Tuple</h3>
    <div class="code">
        let x: [string, number];
        x = [10, 'Hello!'];
    </div>
    <div class="log">
        Types of property '0' are incompatible. Type 'number' is not assignable to type 'string'.
    </div>

    <h3>Enum</h3>
    <div class="code">
        enum Color {Red, Green, Blue};
        let c: Color = Color.Green;
        console.log(c);
    </div>
    <div class="log">
        1
    </div>

    <h2>Variable Declarations</h2>
    <ul>
        <li>
            let はローカル変数。
        </li>
        <li>
            const で宣言した連想配列はもちろん後で書き換えられないが、 プロパティなら書き換え可能。
        </li>
        <li>
            初見。
            <div class="code">
                let [first, ...rest] = [1, 2, 3, 4];
            </div>
        </li>
    </ul>

    <h2>Interfaces</h2>
    <ul>
        <li>
            動きの確認。
            <div class="code">
                interface LabelledValue {
                    label: string;
                 }

                 function printLabel(labelledObj: LabelledValue) {
                 console.log(labelledObj.label);
                 }

                 let myObj = {size: 10, label: "Size 10 Object"};
                 printLabel(myObj);
            </div>
            <div class="log">
                Size 10 Object
            </div>
        </li>
        <li>
            Optional Propaties
            <div class="code">
                interface SquareConfig {
                    color?: string;
                    width?: number;
                }

                function createSquare(config: SquareConfig): { color: string; area: number } {
                    let newSquare = { color: "white", area: 100 };
                    if (config.color) {
                        newSquare.color = config.color;
                    }
                    if (config.width) {
                        newSquare.area = config.width * config.width;
                    }
                    return newSquare;
                }

                let mySquare = createSquare({ color: "black" });
                console.log('color: ' + mySquare.color);
                console.log('area: ' + mySquare.area);
            </div>
            <div class="log">
                color: black
                area: 100
            </div>
        </li>
        <li>
            Function Types
            <div class="code">
                interface SearchFunc {
                    (source: string, subString: string): boolean;   // (仮引数1: 型, 仮引数2: 型): 返り値の型;
                }
            </div>
        </li>
        <li>
            Class Types の基本形
            <div class="code">
                interface ClockInterface {
                    currentTime: Date;
                }

                class Clock implements ClockInterface {
                    currentTime: Date;
                    constructor(h: number, m: number) { }
                }
            </div>
        </li>
        <li>
            interface の拡張
            <div class="code">
                interface Shape {
                    color: string;
                }

                interface PenStroke {
                    penWidth: number;
                }

                interface Square extends Shape, PenStroke {
                    sideLength: number;
                }
            </div>
        </li>
    </ul>


    <h2>Classes</h2>
    <ul>
        <li>
            挨拶してもらった。
            <div class="code">
                class Greeter {
                    greeting: string;
                    constructor(message: string) {
                        this.greeting = message;
                    }
                    greet() {
                        return "Hello, " + this.greeting;
                    }
                }

                let greeter = new Greeter("world");

                console.log(greeter.greet());
            </div>
            <div class="log">
                Hello, World
            </div>
        </li>
        <li>
            アクセス権は何もしてしなければ public。private はクラス内部からのみ。
            protected は自身のクラスと、その子クラスからのみ。
        </li>
        <li>
            抽象クラスの扱い
            <div class="code">
                abstract class Animal {
                    private _name: string;

                	constructor(name: string){
                		this._name = name;
                	}

                	get name(): string {
                		return this._name;
                	}
                }

                let animal = new Animal('Dog');	// これはダメ

                class Dog extends Animal {
                	// 何らかの処理
                }

                let dog = new Dog('Pochi');	// これはOK

                console.log(dog.name);
            </div>
            <div class="log">
                Pochi
            </div>
        </li>
    </ul>

    <h2>Functions</h2>
    <li>
        仮引数、返り値の型の指定にはこんな書き方も。
        <div class="code">
            let myAdd: (x: number, y: number)=>number =
                function(x: number, y: number): number { return x+y; };

            /* これはNG */
            let myAdd: (x: number, y: number)=>number =
                function(x: number, y: number): number { return 'hello'; };
        </div>
    </li>
    <li>
        Optional Parameters
        <div class="code">
            function buildName(firstName: string, lastName: string) {
                return firstName + " " + lastName;
            }

            let result1 = buildName("Bob");                  // これはNG. 実引数が少ない。
            let result2 = buildName("Bob", "Adams", "Sr.");  // これもNG. 実引数が多い。
            let result3 = buildName("Bob", "Adams");         // OK.
        </div>
        <div class="code">
            function buildName(firstName: string, lastName?: string) {
                if (lastName)
                    return firstName + " " + lastName;
                else
                    return firstName;
            }

            let result1 = buildName("Bob");                  // OK. 第2に引数は optional であるため。
            let result2 = buildName("Bob", "Adams", "Sr.");  // NG. 多い。
            let result3 = buildName("Bob", "Adams");         // OK.
        </div>
    </li>

    <h2>Generics</h2>
    <ul>
        <li>
            引数をそのまま返す関数 identity() を例に。
            引数、返り値の型が決まっていれば、次のように書けばOK。
            <div>
                function identity(arg: number): number {
                    return arg;
                }
            </div>
        </li>
        <li>
            では、型が決まっていなければ……？
            1つの方法として、型に<b>any</b> を適用してみる。
            <div class="code">
                function identity(arg: any): any {
                    return arg;
                }
            </div>
        </li>
        <li>
            一見、上記の書き方で良さそうに思える。しかし、実は関数が値を返す時に型情報を失ってしまう。
            例えば、identitiy() に number 型の変数を与えても、返ってくるのは any 型である。
        </li>
        <li>
            結論から先に。こんな風に書こう。
            <div class="code">
                function identity&lt;T&gt;(arg: T): T {
                    return arg;
                }
            </div>
            function 関数名&lt;型パラメータ&gt;(引数:型パラメータ):型パラメータ{}
        </li>
        <li>
            そして、こんな感じで使おう。
            <div class="code">
                let output = identity<string>("myString");
            </div>
        </li>
    </ul>

    <h2>Enums</h2>
    <ul>
        <li>
            列挙型の要素には、いろいろな演算子を適用した結果を与えられる。
            <div class="code">
                enum FileAccess {
                    // constant members
                    None,
                    Read    = 1 << 1,
                    Write   = 1 << 2,
                    ReadWrite  = Read | Write,
                    // computed member
                    G = "123".length
                }

                console.log(FileAccess.ReadWrite);
            </div>
        </li>
    </ul>

    <!-- 4/20 -->
    <h2>Type Inference</h2>
    <ul>
        <li>
            基本的な形。
            <div class="code">
                let x = 3;  // この x は number型と推論される。
            </div>
        </li>
    </ul>
    <h2>Type Compatibility</h2>
    <ul>
        <li>
            型の互換。これはOK。
            <div class="code">
                interface Named {
                    name: string;
                }

                let x: Named;

                // y's inferred type is { name: string; location: string; }
                let y = { name: 'Alice', location: 'Seattle' };
                x = y;

                function greet(n: Named) {
                    alert('Hello, ' + n.name);
                }
                greet(y); // OK.
            </div>
        </li>
        <li>
            これはNG。
            <div class="code">
                interface Named {
                    name: string;
                }

                let x: Named;

                // y's inferred type is { name: string; location: string; }
                let y = { name: 'Alice', location: 'Seattle' };
                x = y;

                function greet(n: Named) {
                    alert('Hello, ' + n.name + 'You are in ' + n.location);
                }
                greet(y); // Error: 'location' does not exist on type 'Named'.
            </div>
        </li>
        <li>
            関数の型の比較。
            <div class="code">
                let x = (a: number) => 0;
                let y = (b: number, s: string) => 1;

                y = x; // OK
                x = y; // Error

                console.log(x);
                console.log(y);
            </div>
            <div class="log">
                function (a) { return 0; }
                function (a) { return 0; }
            </div>
        </li>
    </ul>
    <h2>Advanced Types</h2>
    <ul>
        <li>
            <b>pet is Fish</b> この書き方は初見。
            <div class="code">
                // OK.
                function isFish(pet: Fish | Bird): pet is Fish {
                    return (<Fish>pet).swim !== undefined;
                }
            </div>
            <div class="code">
                // NG. Type 'string' is not assignable to type 'boolean'.
                function isFish(pet: Fish | Bird): pet is Fish {
                    return 'hoge';
                }
            </div>
        </li>
        <li>
            typeof, instanceof で比較できる。Python にも同じようなものが。
            <div class="code">
                // e.g.
                if (typeof padding === "number") {
                    return ture;
                }

                // e.g.
                if (padder instanceof StringPadder) {
                    padder; // type narrowed to 'StringPadder'
                }
            </div>
        </li>
        <li>
            Intersection Types（交差型）とはなんだろう。``これは union型に非常に近い関係性があるが、
            別な使われ方をする。例えば、交差型<b>Person &amp; Serializable &amp; Loggable</b>
            について考えてみよう。これは、あるオブジェクトが3つの型を持つことを意味する。
            実際上は、mixin を使う場面でよく目にするだろう。"
            <div class="code">
                function extend<T, U>(first: T, second: U): T & U {
                    let result = <T & U>{};
                    for (let id in first) {
                        (<any>result)[id] = (<any>first)[id];
                    }
                    for (let id in second) {
                        if (!result.hasOwnProperty(id)) {
                            (<any>result)[id] = (<any>second)[id];
                        }
                    }
                    return result;
                }

                class Person {
                    constructor(public name: string) { }
                }
                interface Loggable {
                    log(): void;
                }
                class ConsoleLogger implements Loggable {
                    log() {
                        // ...
                    }
                }
                var jim = extend(new Person("Jim"), new ConsoleLogger());
                var n = jim.name;
                jim.log();
            </div>
        </li>
        <li>
            こんな型指定の仕方もある。
            <div class="code">
                type Name = string;
                type NameResolver = () => string;
                type NameOrResolver = Name | NameResolver;
                function getName(n: NameOrResolver): Name {
                    if (typeof n === 'string') {
                        return n;
                    }
                    else {
                        return n();
                    }
                }
            </div>
        </li>
        <li>
            リテラルな文字も型として扱える。
            <div class="code">
                type Easing = "ease-in" | "ease-out" | "ease-in-out";
                class UIElement {
                    animate(dx: number, dy: number, easing: Easing) {
                        if (easing === "ease-in") {
                            // ...
                        }
                        else if (easing === "ease-out") {
                        }
                        else if (easing === "ease-in-out") {
                        }
                        else {
                            // error! should not pass null or undefined.
                        }
                    }
                }

                let button = new UIElement();
                button.animate(0, 0, "ease-in");
                button.animate(0, 0, "uneasy"); // NG. "uneasy" という型は Easing に与えていないため。
            </div>
            <div class="log">
                Argument of type '"uneasy"' is not assignable to parameter of type '"ease-in" | "ease-out" | "ease-in-out"'
            </div>
        </li>
    </ul>

    <h2>Iterators and Generators</h2>
    <ul>
        <li>
            <b>for .. of</b> ステートメント
            <div class="code">
                let someArray = [1, "string", false];

                for (let entry of someArray) {
                    console.log(entry); // 1, "string", false
                }
            </div>
        </li>
        <li>
            <b>for .. of</b> と <b>for .. in</b> の違い
            <div class="code">
                let list = [4, 5, 6];
                console.log('for .. in');
                for (let i in list) {
                   console.log(i); // "0", "1", "2",
                }

                console.log('for .. of');
                for (let i of list) {
                   console.log(i); // "4", "5", "6"
                }
            </div>
            <div class="log">
                for .. in
                0
                1
                2
                for .. of
                4
                5
                6
            </div>
        </li>
    </ul>

    <h2>Modules</h2>
    <ul>
        <li>
            Export a declaration and statements.
        </li>
        <li>
            Import
            <div class="code">
                import { ZipCodeValidator } from "./ZipCodeValidator";
                let myValidator = new ZipCodeValidator();
            </div>
        </li>
        <li>
            こんな import の仕方も。Python と非常に似ている。
            <div class="code">
                import * as validator from "./ZipCodeValidator";
                let myValidator = new validator.ZipCodeValidator();
            </div>
        </li>
        <li>
            <b>default</b> は export したモジュールのデフォルト値。
        </li>
        <li>
            モジュールを <b>export =</b> で export。
            <b>import let = require("module")</b> で import。<br />
            <div class="code">
                let numberRegexp = /^[0-9]+$/;
                class ZipCodeValidator {
                    isAcceptable(s: string) {
                        return s.length === 5 && numberRegexp.test(s);
                    }
                }
                export = ZipCodeValidator;
            </div>
            <small>ZipCodeValidator.ts</small>
            <div class="code">
                import zip = require("./ZipCodeValidator");

                // Some samples to try
                let strings = ["Hello", "98052", "101"];

                // Validators to use
                let validator = new zip();

                // Show whether each string passed each validator
                strings.forEach(s => {
                  console.log(`"${ s }" - ${ validator.isAcceptable(s) ? "matches" : "does not match" }`);
                });
            </div>
            <small>Test.ts</small>
        </li>
        <li>
            CommonJS と AMD とは……？（<a href="https://tsuchikazu.net/javascript-module/" target="_blank">参考</a>）
        </li>
    </ul>

    <h2>Namespaces</h2>
    <li>
        バリデーションを行うプログラムを例に
        <div class="code">
            interface StringValidator {
                isAcceptable(s: string): boolean;
            }

            let lettersRegexp = /^[A-Za-z]+$/;
            let numberRegexp = /^[0-9]+$/;

            class LettersOnlyValidator implements StringValidator {
                isAcceptable(s: string) {
                    return lettersRegexp.test(s);
                }
            }

            class ZipCodeValidator implements StringValidator {
                isAcceptable(s: string) {
                    return s.length === 5 && numberRegexp.test(s);
                }
            }

            // Some samples to try
            let strings = ["Hello", "98052", "101"];

            // Validators to use
            let validators: { [s: string]: StringValidator; } = {};
            validators["ZIP code"] = new ZipCodeValidator();
            validators["Letters only"] = new LettersOnlyValidator();

            // Show whether each string passed each validator
            for (let s of strings) {
                for (let name in validators) {
                    let isMatch = validators[name].isAcceptable(s);
                    console.log(`'${ s }' ${ isMatch ? "matches" : "does not match" } '${ name }'.`);
                }
            }
        </div>
        <small>シンプルに1つのファイルにまとめた例</small>
        <div class="log">
            'Hello' does not match 'ZIP code'.
            'Hello' matches 'Letters only'.
            '98052' matches 'ZIP code'.
            '98052' does not match 'Letters only'.
            '101' does not match 'ZIP code'.
            '101' does not match 'Letters only'.
        </div>

        <div class="code">
            <b>namespace Validation</b> {
                export interface StringValidator {
                    isAcceptable(s: string): boolean;
                }

                const lettersRegexp = /^[A-Za-z]+$/;
                const numberRegexp = /^[0-9]+$/;

                export class LettersOnlyValidator implements StringValidator {
                    isAcceptable(s: string) {
                        return lettersRegexp.test(s);
                    }
                }

                export class ZipCodeValidator implements StringValidator {
                    isAcceptable(s: string) {
                        return s.length === 5 && numberRegexp.test(s);
                    }
                }
            }

            // Some samples to try
            let strings = ["Hello", "98052", "101"];

            // Validators to use
            let validators: { [s: string]: Validation.StringValidator; } = {};
            validators["ZIP code"] = new Validation.ZipCodeValidator();
            validators["Letters only"] = new Validation.LettersOnlyValidator();

            // Show whether each string passed each validator
            for (let s of strings) {
                for (var name in validators) {
                    console.log(`"${ s }" - ${ validators[name].isAcceptable(s) ? "matches" : "does not match" } ${ name }`);
                }
            }
        </div>
        <small>名前空間を適用した例</small>
    </li>
    <li>
        複数のファイルに分けることもできる。その場合、コンパイルは次のようにする。
        <div class="code">
            tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts
        </div>
    </li>
    <li>
        htmlファイルからは次のように呼び出す。
        <div class="code">
            &lt;script src=&quot;Validation.js&quot; type=&quot;text/javascript&quot; /&gt;
            &lt;script src=&quot;LettersOnlyValidator.js&quot; type=&quot;text/javascript&quot; /&gt;
            &lt;script src=&quot;ZipCodeValidator.js&quot; type=&quot;text/javascript&quot; /&gt;
            &lt;script src=&quot;Test.js&quot; type=&quot;text/javascript&quot; /&gt;
        </div>
        <small>MyTestPage.html</small>
    </li>

    <h2>Mixins</h2>
    <ul>
        <li>
            Mixin サンプルコードの全体
            <div class="code">
                // Disposable Mixin
                class Disposable {
                    isDisposed: boolean;
                    dispose() {
                        this.isDisposed = true;
                    }

                }

                // Activatable Mixin
                class Activatable {
                    isActive: boolean;
                    activate() {
                        this.isActive = true;
                    }
                    deactivate() {
                        this.isActive = false;
                    }
                }

                class SmartObject implements Disposable, Activatable {
                    constructor() {
                        setInterval(() => console.log(this.isActive + " : " + this.isDisposed), 500);
                    }

                    interact() {
                        this.activate();
                    }

                    // Disposable
                    isDisposed: boolean = false;
                    dispose: () => void;
                    // Activatable
                    isActive: boolean = false;
                    activate: () => void;
                    deactivate: () => void;
                }
                applyMixins(SmartObject, [Disposable, Activatable]);

                let smartObj = new SmartObject();
                setTimeout(() => smartObj.interact(), 1000);

                ////////////////////////////////////////
                // In your runtime library somewhere
                ////////////////////////////////////////

                function applyMixins(derivedCtor: any, baseCtors: any[]) {
                    baseCtors.forEach(baseCtor => {
                        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
                            derivedCtor.prototype[name] = baseCtor.prototype[name];
                        });
                    });
                }
            </div>
        </li>
        <li>
            上記のコードを詳しく見ていく。
            まず、2つの Mixinクラス <b>Disposable</b>, <b>Activatable</b> を用意する。
            <div class="code">
                // Disposable Mixin
                class Disposable {
                    isDisposed: boolean;
                    dispose() {
                        this.isDisposed = true;
                    }

                }

                // Activatable Mixin
                class Activatable {
                    isActive: boolean;
                    activate() {
                        this.isActive = true;
                    }
                    deactivate() {
                        this.isActive = false;
                    }
                }
            </div>
        </li>
        <li>
            <b>extends</b> の代わりに <b>implements</b> を使う。
            クラスをインターフェースとして扱う。
            <div class="code">
                class SmartObject implements Disposable, Activatable {
            </div>
        </li>
        <li>
            クラス内でメンバを宣言。
            <div class="code">
                // Disposable
                isDisposed: boolean = false;
                dispose: () => void;
                // Activatable
                isActive: boolean = false;
                activate: () => void;
                deactivate: () => void;
            </div>
        </li>
        <li>
            mixins と クラスをミックスし、クラスに実装を取り込む。
            <div class="code">
                applyMixins(SmartObject, [Disposable, Activatable]);

                function applyMixins(derivedCtor: any, baseCtors: any[]) {
                    baseCtors.forEach(baseCtor => {
                        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
                            derivedCtor.prototype[name] = baseCtor.prototype[name];
                        });
                    });
                }
            </div>
        </li>
    </ul>

    <h2>Triple-Slash Directives</h2>
    <ul>
        <li>
            ファイルへの参照を埋め込む。
        </li>
        <li>
            型定義ファイル<b>test.d.ts</b> と、これをコンパイルした<b>test.js</b>について考えよう。
            前者へは開発者のみがアクセス可能であればよい。
            後者へは実行する誰もがアクセス可能であるべきである。
        </li>
        <li>

        </li>
    </ul>

</body>

</html>
